[{"categories":["Web前端","React"],"content":"本文提供了React的基础语法和基本知识点，帮助人们快速理解和上手React\nReact介绍 知识程度 了解： 熟悉： 掌握： 精通： React是什么 React是一个用于构建Web和原生交互界面的库\n用途 网页加载速度更快 React的优势 组件化的开发方式\n性能更高\n跨平台支持\n开发环境搭建 使用create-react-app快速搭建开发环境（脚手架方式创建React项目） 使用vscode编译器，自主选择一个目录\n打开终端\n执行命令：npx create-react-app react-basic\nnpx：Node.js工具命令，用于查找并执行后续的包命令\ncreate-react-app：核心包(固定写法)，用于创建React项目\nreact-basic：React项目的名称，可以自定义\ncd react-basic进入项目\nnpm start启动项目\nJSX基础-概念和本质 什么是JSX 概念：JSX是Javascript和XML(HTML)的缩写，表示在**JS代码中编写HTML模板结构**，它是React中编写UI模板的方式\n这是最基本的框架，必须要有，缺一不可\nfunction App() { return ( \u0026lt;div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; JSX的本质 JSX不是标准的JS语法，是**JS的语法扩展**，浏览器本身不能识别，需要通过解析工具做解析才能在浏览器中运行\nJSX基础-高频场景 JSX中使用JS表达式 在JSX中，通过**大括号语法{}**识别Javascript中的表达式\nJSX中实现复杂条件渲染 需求：列表中需要根据文章状态适配三种情况，单图，三图和无图三种模式 解决方案：自定义函数+if判断语句 function messType(num) { if (num == 1) { return \u0026#39;单图模式\u0026#39; } else if (num == 3) { return \u0026#39;三图模式\u0026#39; } else { return \u0026#39;无图模式\u0026#39; } } let number = 0 function App() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;{messType(number)}\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;{messType(number + 1)}\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;{messType(number + 3)}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; React中的事件绑定 React基础事件绑定 语法：on + 事件名称 = {事件处理程序} function App() { function clickHandle() { console.log(\u0026#39;button被点击了\u0026#39;); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={clickHandle}\u0026gt;点击我\u0026lt;/button\u0026gt; {/* \u0026lt;button onClick={function () { console.log(\u0026#39;button被2点击了\u0026#39;) }}\u0026gt;点击我\u0026lt;/button\u0026gt; */} \u0026lt;/div\u0026gt; ); } export default App; 使用事件对象参数 语法：在事件回调函数中设置形参e function App() { function clickHandle(e) { console.log(\u0026#39;button被点击了\u0026#39;, e); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={clickHandle}\u0026gt;点击我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 传递自定义参数 语法：事件绑定位置改造成箭头函数 不能直接写函数调用，需要一个函数引用\nfunction App() { function clickHandle(name) { console.log(\u0026#39;button被点击了\u0026#39;, name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; clickHandle(\u0026#39;jack\u0026#39;)}\u0026gt;点击我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 若不改造成箭头函数，会变成自动调用2次，并且点击事件无效\n同时传递事件对象和自定义参数 function App() { function clickHandle(e, name) { console.log(\u0026#39;button被点击了\u0026#39;, name, e); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={(e) =\u0026gt; clickHandle(e, \u0026#39;jack\u0026#39;)}\u0026gt;点击我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; React中的组件 React组件 组件：首字母大写的函数，内部存放组件的逻辑和视图UI，渲染组件时，把组件当成标签书写即可\n// 定义组件 function Button() { return \u0026lt;button\u0026gt;clike me\u0026lt;/button\u0026gt; } function App() { return ( \u0026lt;div\u0026gt; {/* 组件的两种使用方式 */} \u0026lt;Button /\u0026gt; \u0026lt;Button\u0026gt;\u0026lt;/Button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; useState useState基础使用 useState是一个函数，通过向组件添加状态变量来控制组件的渲染结果\n本质：状态变量发生变化，组件的视图UI也跟着变化**(数据驱动视图)**，即达到实时更新的效果 应用：评论发布，评论列表实时更新 const [count, setCount] = useState(0); useState返回值是数组 数组中，第一个参数是状态变量，第二个参数是set函数，用来修改状态变量 useState的参数作为count的初始值 修改状态的规则 状态不可变 在React中，状态被认为是只读，直接修改状态不能引发视图更新，通过set函数进行修改才能引发视图更新\n// 导入useState钩子 import { useState } from \u0026#39;react\u0026#39;; function App() { const [count, setCount] = useState(0); const handleClick = () =\u0026gt; { // 直接修改，无法引发视图更新 // count++ // console.log(count); // 用set函数传入新值来修改count，会自动重新使用新的count来渲染UI setCount(count + 1); console.log(count); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;增加\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 注意 使用useState钩子，需要导入 useState是异步更新的，因此上述代码在每次点击时，控制台输出的是点击前的结果，想立即获取到更新的值可以通过useEffect实现 运行机制：点击按钮，调用handleClick函数，当调用setCount函数时，React将新的state放入队列中，继续执行后面的代码console.log(count)，然后开始渲染，将count赋值为count+1\n修改对象状态 规则：set一个全新的对象来进行修改 // 导入useState钩子 import { useState } from \u0026#39;react\u0026#39;; function App() { const [form, setForm] = useState({ name: \u0026#39;jack\u0026#39; }); const handleClick = () =\u0026gt; { setForm({ name: \u0026#39;john\u0026#39; }) console.log(form.name); } return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={handleClick}\u0026gt;点击我\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 组件的样式处理 组件基础样式方案 .color{ color: red; } import \u0026#39;./index.css\u0026#39; function App() { return ( \u0026lt;div\u0026gt; {/* 行内样式 */} \u0026lt;p class=\u0026#39;color\u0026#39;\u0026gt;我是p标签\u0026lt;/p\u0026gt; {/* class类名控制 */} \u0026lt;span style={{ color: \u0026#39;green\u0026#39; }}\u0026gt;我是span标签\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; css中使用的是.，因此在UI设计中，也要用class或者className作为属性，否则样式不生效\n案例：B站评论 B站评论案例 需求 渲染评论列表 删除评论实现 渲染导航Tab和高亮实现 评论列表排序功能实现 渲染评论列表 核心思路 使用useState维护评论列表 使用**map方法**对列表数据进行遍历渲染 // 导入useState钩子 import { useState } from \u0026#39;react\u0026#39;; // 评论列表数据 const list = [ \u0026#39;评论1\u0026#39;, \u0026#39;评论2\u0026#39;, \u0026#39;评论3\u0026#39; ] function App() { // 使用useState维护评论列表 const [comments, setComments] = useState(list); // 定义一个函数，用于添加评论到列表 function addComment() { let comment = document.querySelector(\u0026#39;input\u0026#39;).value; // ...comments:获取列表当前的所有数据，并返回一个列表 // 更新comments状态，将comment添加到comments列表的末尾，并且React会重新渲染列表 setComments([...comments, comment]); document.querySelector(\u0026#39;input\u0026#39;).value = \u0026#39;\u0026#39;; } return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#39;发一条友善的评论\u0026#39;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={addComment}\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {/* 使用map方法对列表数据进行遍历渲染 */} {comments.map(item =\u0026gt; ( \u0026lt;li\u0026gt;{item}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 实现评论删除 需求： 只有自己的评论才显示删除按钮 点击删除按钮，删除当前评论，列表中不再显示 核心思路 删除显示 - 条件渲染 删除功能 - 拿到当前项id，以id为条件对评论列表做filter过滤 // 导入useState钩子 import { useState } from \u0026#39;react\u0026#39;; // 评论列表数据 const list = [{ uid: 1, content: \u0026#39;评论1\u0026#39; }, { uid: 2, content: \u0026#39;评论2\u0026#39; }, { uid: 3, content: \u0026#39;评论5\u0026#39; }] // 当前登录账号的uid const uid = 123; function App() { // 使用useState维护评论列表 const [comments, setComments] = useState(list); // 定义一个函数，用于添加评论到列表 function addComment() { let comment = document.querySelector(\u0026#39;input\u0026#39;).value; let id = uid let tempObject = { uid: id, content: comment } setComments([...comments, tempObject]); document.querySelector(\u0026#39;input\u0026#39;).value = \u0026#39;\u0026#39;; } function handleDel(id,index) { // filter方法：满足条件保留 let tempList = comments.filter((item,i) =\u0026gt; i!==index); setComments(tempList); } function delBtn(id,index) { if (uid == id) { return \u0026lt;button onClick={() =\u0026gt; handleDel(id,index)}\u0026gt;删除\u0026lt;/button\u0026gt; } else { return \u0026#39;\u0026#39; } } return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#39;发一条友善的评论\u0026#39;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={addComment}\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {/* 使用map方法对列表数据进行遍历渲染 */} {comments.map((item,index) =\u0026gt; ( \u0026lt;li\u0026gt;{item.content} your uid {item.uid} {delBtn(item.uid,index)}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 渲染Tab + 点击高亮实现 需求：点击哪个Tab项，哪个做高亮处理 核心思路：点击谁就把谁的**type(独一无二的标识)记录下来，与遍历的每一项的type做匹配**，匹配到就负责高亮 span{ margin: 20px; color: #ccc; } function App() { function light(e) { const type = e.target let div = document.querySelectorAll(\u0026#39;div span\u0026#39;) for (let i = 0; i \u0026lt; div.length; i++) { div[i].style.color = \u0026#39;#ccc\u0026#39; } type.style.color = \u0026#39;#000\u0026#39; } return ( \u0026lt;div\u0026gt; \u0026lt;div onClick={light}\u0026gt; \u0026lt;span\u0026gt;最新\u0026lt;/span\u0026gt; | \u0026lt;span\u0026gt;最热\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 排序实现 需求：点击最新，评论列表按照创建时间倒叙排列（新的在前），点击最热按照点赞数排序（多的在前） // 导入useState钩子 import { useState } from \u0026#39;react\u0026#39;; // 评论列表数据 let list = [{ uid: 1, content: \u0026#39;评论1\u0026#39;, time: \u0026#39;2023-11-11\u0026#39;, count: 100 }, { uid: 2, content: \u0026#39;评论2\u0026#39;, time: \u0026#39;2022-11-11\u0026#39;, count: 200 }, { uid: 3, content: \u0026#39;评论5\u0026#39;, time: \u0026#39;2021-11-11\u0026#39;, count: 300 } ] // 当前登录账号的uid const uid = 123; function App() { // 使用useState维护评论列表 const [comments, setComments] = useState(list); // 定义一个函数，用于添加评论到列表 function addComment() { let comment = document.querySelector(\u0026#39;input\u0026#39;).value; let id = uid let count = 1 let time = \u0026#39;2023-12-27\u0026#39; let tempObject = { uid: id, content: comment, count: count, time: time } setComments([...comments, tempObject]); document.querySelector(\u0026#39;input\u0026#39;).value = \u0026#39;\u0026#39;; } function handleDel(id, index) { let tempList = comments.filter((item, i) =\u0026gt; i !== index); setComments(tempList); } function delBtn(id, index) { if (uid == id) { return \u0026lt;button onClick={() =\u0026gt; handleDel(id, index)}\u0026gt;删除\u0026lt;/button\u0026gt; } else { return \u0026#39;\u0026#39; } } function light(e) { const type = e.target let div = document.querySelectorAll(\u0026#39;div span\u0026#39;) for (let i = 0; i \u0026lt; div.length; i++) { div[i].style.color = \u0026#39;#ccc\u0026#39; } type.style.color = \u0026#39;#000\u0026#39; if (type.innerHTML === \u0026#39;最新\u0026#39;) { // 在使用useState中，要避免修改原来的值，所以不用list，使用[...comments]，不使用list，保证状态的更新渲染 // 通过localeCompare方法实现按照时间先后顺序比较 // 不能使用减法，在js中如果无法解析为有效数字的字符串，直接返回NaN而导致无法比较，\u0026#39;2023-11-11\u0026#39;形如时间字符串格式，导致无法正确解析为有效数字的字符串，因为它在时间字符串和普通字符串徘徊而导致无法正确解析为 有效数字的字符串 和 有\u0026#39;-\u0026#39;非数字字符的原因 setComments([...comments].sort((a, b) =\u0026gt; b.time.localeCompare(a.time))) } else { setComments([...comments].sort((a, b) =\u0026gt; b.count - a.count)) } } return ( \u0026lt;div\u0026gt; \u0026lt;div onClick={light}\u0026gt; \u0026lt;span\u0026gt;最新\u0026lt;/span\u0026gt; | \u0026lt;span\u0026gt;最热\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#39;发一条友善的评论\u0026#39;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={addComment}\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {/* 使用map方法对列表数据进行遍历渲染 */} {comments.map((item, index) =\u0026gt; ( \u0026lt;li\u0026gt;{item.content} your uid {item.uid} your create time {item.time} your click num {item.count}{delBtn(item.uid, index)}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 受控表单绑定 使用React组件的状态(useState)控制表单的状态\nimport \u0026#39;./App.css\u0026#39;; import { useState } from \u0026#39;react\u0026#39; function App() { const [value, setValue] = useState(\u0026#39;\u0026#39;) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* {\u0026lt;input\u0026gt;\u0026lt;/input\u0026gt;} */} {/* 表单元素能够自己维护state，根据用户的输入进行更新 ------------------------ 受控组件 */} {/* onchange事件：当用户在input输入时执行一段JavaScript代码 */} {/* 通过value属性绑定状态，onchange属性绑定状态同步的函数 */} {\u0026lt;input type=\u0026#39;text\u0026#39; value={value} onChange={(e) =\u0026gt; setValue(e.target.value)} /\u0026gt;} \u0026lt;/div\u0026gt; ); } export default App; 需要在浏览器中安装React Developer Tools插件，然后在开发者工具中的Components中查看State的变化\nReact中获取DOM 使用useRef React Hook钩子函数\n第一步 使用useRef创建ref对象，并与JSX绑定\nconst inputRef = useRef(null)\n\u0026lt;input type='text' ref={inputRef} /\u0026gt;\n第二步 在DOM可用下，以事件对象的形式，通过inputRef.current拿到DOM对象\nconsole.log(inputRef.current);\nimport \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const inputRef = useRef(null) function getInput() { console.log(inputRef.current); } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* ref:让不受控制组件的维护变得容易，能够获取DOM节点或React元素实例的工具。允许用户访问 DOM 节点或者在 render 方法中创建的React元素 */} {/* 应用场景 */} {/* 1、对DOM 元素焦点的控制、内容选择或者媒体播放； */} {/* 2、通过对DOM元素控制，触发动画特效； */} \u0026lt;input type=\u0026#39;text\u0026#39; ref={inputRef} /\u0026gt; \u0026lt;button onClick={getInput}\u0026gt;点击我获取input的dom元素\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 组件通信 组件之间的数据传递\n父传子 - 基础实现 实现步骤 父组件传递数据 - 在子组件标签上绑定属性 子组件接收数据 - 子组件通过**props参数**接收数据 import \u0026#39;./App.css\u0026#39;; function App() { const name = \u0026#39;this is app name\u0026#39; function Son(props) { console.log(props); return \u0026lt;div\u0026gt;this is Son name\u0026lt;/div\u0026gt; } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Son name={name} age={20} isTrue={false} list={[\u0026#39;Vue\u0026#39;, \u0026#39;React\u0026#39;]} obj={{ name: \u0026#39;jack\u0026#39; }} cb={() =\u0026gt; console.log(123)} child={\u0026lt;span\u0026gt;this is span child\u0026lt;/span\u0026gt;} \u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 注意 组件只能读取props中的数据 props参数名是一个自定义参数，它接收父组件传递的数据 父传子 - 特殊的prop children 使用场景：当把内容嵌套在子组件标签中，父组件会自动在名为children的prop属性中接收该内容\nimport \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const name = \u0026#39;this is app name\u0026#39; function Son(props) { console.log(props); return \u0026lt;div\u0026gt;this is Son name\u0026lt;/div\u0026gt; } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Son\u0026gt; \u0026lt;span\u0026gt;这是一个span标签\u0026lt;/span\u0026gt; \u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 父子组件通信 - 子传父 核心思路：在子组件中调用父组件中的函数并传递参数 import \u0026#39;./App.css\u0026#39;; function App() { // 父组件函数 const getMsg = (msg) =\u0026gt; console.log(msg) // 通过对象模型解构获取getMs function Son({ onGetMsg }) { const sonMsg = \u0026#39;this is son msg\u0026#39; return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; onGetMsg(sonMsg)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 子组件调用父组件函数 */} \u0026lt;Son onGetMsg={getMsg}\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 使用状态提升实现兄弟组件通信 实现思路：通过父组件进行兄弟组件之间的数据传递 A组件通过子传父把数据传给父组件App App拿到数据通过父传子传递给B组件 import \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const getMsg = (msg) =\u0026gt; { console.log(msg); setMsg(msg) } const [msg, setMsg] = useState(\u0026#39;\u0026#39;) function SonA({ onGetAMsg }) { const SonAMsg = \u0026#39;this is A name\u0026#39; return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; onGetAMsg(SonAMsg)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } function SonB(props) { console.log(props); } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;SonA onGetAMsg={getMsg}\u0026gt;\u0026lt;/SonA\u0026gt; \u0026lt;SonB msg={msg}\u0026gt;\u0026lt;/SonB\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 以下是错误的写法\nfunction SonB(props) { console.log(props); } /** 为什么这种方法不能够输出console.log(props)？ */ const getMsg = (msg) =\u0026gt; { return \u0026lt;SonB getMsgApp={msg}\u0026gt;\u0026lt;/SonB\u0026gt; } function SonA({ onGetAMsg }) { const SonAMsg = \u0026#39;this is A name\u0026#39; return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={() =\u0026gt; onGetAMsg(SonAMsg)}\u0026gt;send\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) } 这段代码不能实现兄弟组件通信的原因是，没有共享状态机制，共享状态机制可以通过useState等实现\n使用Context机制跨层级组件通信 实现步骤 使用createContext方法创建一个上下文对象Ctx 在顶层组件App中使用**Ctx.Provider组件**提供数据 在底层组件B中使用useContext钩子函数获取数据 import \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const Ctx = createContext() const msg = \u0026#39;this is app name\u0026#39; function A() { return ( \u0026lt;div\u0026gt; this is A app \u0026lt;B /\u0026gt; \u0026lt;/div\u0026gt; ) } function B() { // 传入上下文对象 const getMsg = useContext(Ctx) return ( // 获取数据 \u0026lt;div\u0026gt;this is B app,{getMsg}\u0026lt;/div\u0026gt; ) } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 提供数据 */} \u0026lt;Ctx.Provider value={msg}\u0026gt; this is App \u0026lt;A /\u0026gt; \u0026lt;/Ctx.Provider\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; useEffect的使用 useEffect的概念理解 useEffect是一个React Hook函数，用于在React组件中创建不是由事件引起，而是渲染本身引起的操作（副作用），比如：**发送AJAX请求，更改DOM**等等\n注意：不发生任何用户事件，组件渲染完毕之后，向服务器要数据\nuseEffect的基础使用 语法：useEffect(() =\u0026gt; { } , []) 参数1：一个副作用函数，函数内部放置要执行的操作 参数2：可选参数，若为空数组，副作用函数在组件渲染完毕之后执行一次 提供案例需求：在组件渲染完毕之后，立刻从服务端获取频道列表数据并显示到页面中\n接口测试地址：http://geek.itheima.net/v1_0/channels\n{\u0026#34;data\u0026#34;:{\u0026#34;channels\u0026#34;:[{\u0026#34;id\u0026#34;:0,\u0026#34;name\u0026#34;:\u0026#34;推荐\u0026#34;},{\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;html\u0026#34;},{\u0026#34;id\u0026#34;:2,\u0026#34;name\u0026#34;:\u0026#34;开发者资讯\u0026#34;},{\u0026#34;id\u0026#34;:4,\u0026#34;name\u0026#34;:\u0026#34;c++\u0026#34;},{\u0026#34;id\u0026#34;:6,\u0026#34;name\u0026#34;:\u0026#34;css\u0026#34;},{\u0026#34;id\u0026#34;:7,\u0026#34;name\u0026#34;:\u0026#34;数据库\u0026#34;},{\u0026#34;id\u0026#34;:8,\u0026#34;name\u0026#34;:\u0026#34;区块链\u0026#34;},{\u0026#34;id\u0026#34;:9,\u0026#34;name\u0026#34;:\u0026#34;go\u0026#34;},{\u0026#34;id\u0026#34;:10,\u0026#34;name\u0026#34;:\u0026#34;产品\u0026#34;},{\u0026#34;id\u0026#34;:11,\u0026#34;name\u0026#34;:\u0026#34;后端\u0026#34;},{\u0026#34;id\u0026#34;:12,\u0026#34;name\u0026#34;:\u0026#34;linux\u0026#34;},{\u0026#34;id\u0026#34;:13,\u0026#34;name\u0026#34;:\u0026#34;人工智能\u0026#34;},{\u0026#34;id\u0026#34;:14,\u0026#34;name\u0026#34;:\u0026#34;php\u0026#34;},{\u0026#34;id\u0026#34;:15,\u0026#34;name\u0026#34;:\u0026#34;javascript\u0026#34;},{\u0026#34;id\u0026#34;:16,\u0026#34;name\u0026#34;:\u0026#34;架构\u0026#34;},{\u0026#34;id\u0026#34;:17,\u0026#34;name\u0026#34;:\u0026#34;前端\u0026#34;},{\u0026#34;id\u0026#34;:18,\u0026#34;name\u0026#34;:\u0026#34;python\u0026#34;},{\u0026#34;id\u0026#34;:19,\u0026#34;name\u0026#34;:\u0026#34;java\u0026#34;},{\u0026#34;id\u0026#34;:20,\u0026#34;name\u0026#34;:\u0026#34;算法\u0026#34;},{\u0026#34;id\u0026#34;:21,\u0026#34;name\u0026#34;:\u0026#34;面试\u0026#34;},{\u0026#34;id\u0026#34;:22,\u0026#34;name\u0026#34;:\u0026#34;科技动态\u0026#34;},{\u0026#34;id\u0026#34;:23,\u0026#34;name\u0026#34;:\u0026#34;js\u0026#34;},{\u0026#34;id\u0026#34;:24,\u0026#34;name\u0026#34;:\u0026#34;设计\u0026#34;},{\u0026#34;id\u0026#34;:25,\u0026#34;name\u0026#34;:\u0026#34;数码产品\u0026#34;},{\u0026#34;id\u0026#34;:26,\u0026#34;name\u0026#34;:\u0026#34;软件测试\u0026#34;}]},\u0026#34;message\u0026#34;:\u0026#34;OK\u0026#34;} import \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const URL = \u0026#39;http://geek.itheima.net/v1_0/channels\u0026#39; const [list, setList] = useState([]) useEffect(() =\u0026gt; { async function getLists() { const res = await fetch(URL) const lists = await res.json(); console.log(lists); setList(lists.data.channels) } getLists() }, []) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span\u0026gt;this is App\u0026lt;/span\u0026gt; \u0026lt;ul\u0026gt; {list.map(item =\u0026gt; \u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt;)} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; useEffect依赖项参数说明 根据传入依赖项的不同，会有不同的执行表现\nuseEffect — 清除副作用 组件卸载时自动执行\n需求：在Son组件渲染时开启计时器，卸载时清除这个计时器\nimport \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { const [time, setTime] = useState(true) function Son() { useEffect(() =\u0026gt; { const timer = setInterval(() =\u0026gt; { console.log(\u0026#39;定时器启动中……\u0026#39;); }, 1000) return () =\u0026gt; { clearInterval(timer) } }, []) return \u0026lt;div\u0026gt;this is son \u0026lt;/div\u0026gt; } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 这里的\u0026amp;\u0026amp;并不是字符串，而是用来通过 条件渲染来控制 计时器的开启与卸载 */} {time \u0026amp;\u0026amp; \u0026lt;Son /\u0026gt;} \u0026lt;button onClick={() =\u0026gt; setTime(false)}\u0026gt;点击我关闭计时器\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 自定义Hook实现 自定义Hook以**use打头的函数**，用来实现逻辑的封装和复用\nReact Hooks使用规则 不能嵌套在if、for、其他函数中\n案例：优化B站评论案例 优化需求 使用请求接口的方法获取评论列表并渲染 使用自定义Hook函数封装数据请求的逻辑 把评论中的每一项抽象成一个独立的组件实现渲染 优化需求 - 通过接口获取评论列表 实现步骤 使用json-server工具模拟接口服务，通过axios发送接口请求 json-server以.json文件作为数据源模拟接口服务的工具 axios是前端请求库 使用useEffect调用接口获取数据 准备工作 在项目中安装json-server，这里假设自己的工程目录为react-basic 在终端运行npm i json-server -D安装json-server 在package.json文件中添加\u0026quot;serve\u0026quot;: \u0026quot;json-server db.json --port 3004\u0026quot; 在终端运行npm run serve 在浏览器打开Resources下的连接查看数据 在项目中安装axios 在终端运行npm install axios命令安装axios 在App.js文件中导入axios 在安装json-server过程中，会影响三处地方，工程目录图\n安装axios\ndb.json数据一栏\n{ \u0026#34;list\u0026#34;: [ { \u0026#34;uid\u0026#34;: 1, \u0026#34;content\u0026#34;: \u0026#34;评论1\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2023-11-11\u0026#34;, \u0026#34;count\u0026#34;: 100 }, { \u0026#34;uid\u0026#34;: 2, \u0026#34;content\u0026#34;: \u0026#34;评论2\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2022-11-11\u0026#34;, \u0026#34;count\u0026#34;: 200 }, { \u0026#34;uid\u0026#34;: 3, \u0026#34;content\u0026#34;: \u0026#34;评论5\u0026#34;, \u0026#34;time\u0026#34;: \u0026#34;2021-11-11\u0026#34;, \u0026#34;count\u0026#34;: 300 } ] } import \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; // 安装axios后要导入 import axios from \u0026#39;axios\u0026#39; function App() { // 使用useState维护评论列表 // const [comments, setComments] = useState(list); // 通过接口获取评论列表 const [comments, setComments] = useState([]); useEffect(() =\u0026gt; { async function getLists() { // 接口获取数据 const res = await axios.get(\u0026#39;http://localhost:3004/list\u0026#39;) const data = await res.data setComments(data) console.log(data); } getLists() }, []) return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 优化需求 - 自定义Hook函数封装数据请求 实现步骤 编写一个use打头的函数 函数内部编写封装的逻辑 return出去组件中用到的状态和方法 组件中调用函数，解构赋值使用 import \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { // Hook函数封装数据请求 function useListData() { // 通过接口获取评论列表 const [comments, setComments] = useState([]); useEffect(() =\u0026gt; { async function getLists() { // 接口获取数据 const res = await axios.get(\u0026#39;http://localhost:3004/list\u0026#39;) const data = await res.data setComments(data) console.log(data); } getLists() }, []) return { comments, setComments } } const { comments, setComments } = useListData() return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 优化需求 - 封装评论项Item组件 需求：App作为“智能组件”负责数据的获取，Item作为“UI组件”负责数据的渲染\nimport \u0026#39;./App.css\u0026#39;; import { createContext, useContext, useEffect, useRef, useState } from \u0026#39;react\u0026#39; function App() { // 封装评论项Item组件 // 函数组件的形参需要是对象 function Item({ item, index }) { return ( \u0026lt;li\u0026gt;{item.content} your uid {item.uid} your create time {item.time} your click num {item.count}{delBtn(item.uid, index)}\u0026lt;/li\u0026gt; ) } return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; {/* 评论列表 */} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {/* 使用map方法对列表数据进行遍历渲染 */} {comments.map((item, index) =\u0026gt; ( \u0026lt;Item item={item} index={index} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; B站评论案例优化完整代码展示\n// 导入useState钩子 import { useEffect, useState } from \u0026#39;react\u0026#39;; // 安装axios后要导入 import axios from \u0026#39;axios\u0026#39; // 当前登录账号的uid const uid = 123; function App() { // Hook函数封装数据请求 function useListData() { // 通过接口获取评论列表 const [comments, setComments] = useState([]); useEffect(() =\u0026gt; { async function getLists() { // 接口获取数据 const res = await axios.get(\u0026#39;http://localhost:3004/list\u0026#39;) const data = await res.data setComments(data) console.log(data); } getLists() }, []) return { comments, setComments } } const { comments, setComments } = useListData() // 封装评论项Item组件 function Item({ item, index }) { return ( \u0026lt;li\u0026gt;{item.content} your uid {item.uid} your create time {item.time} your click num {item.count}{delBtn(item.uid, index)}\u0026lt;/li\u0026gt; ) } // 定义一个函数，用于添加评论到列表 function addComment() { let comment = document.querySelector(\u0026#39;input\u0026#39;).value; let id = uid let count = 1 let time = \u0026#39;2023-12-27\u0026#39; let tempObject = { uid: id, content: comment, count: count, time: time } setComments([...comments, tempObject]); document.querySelector(\u0026#39;input\u0026#39;).value = \u0026#39;\u0026#39;; } function handleDel(id, index) { let tempList = comments.filter((item, i) =\u0026gt; i !== index); setComments(tempList); } function delBtn(id, index) { if (uid == id) { return \u0026lt;button onClick={() =\u0026gt; handleDel(id, index)}\u0026gt;删除\u0026lt;/button\u0026gt; } else { return \u0026#39;\u0026#39; } } function light(e) { const type = e.target let div = document.querySelectorAll(\u0026#39;div span\u0026#39;) for (let i = 0; i \u0026lt; div.length; i++) { div[i].style.color = \u0026#39;#ccc\u0026#39; } type.style.color = \u0026#39;#000\u0026#39; if (type.innerHTML === \u0026#39;最新\u0026#39;) { // 使用[...comments]，不使用list，保证状态的更新渲染 // 在使用useState中，要避免修改原来的值，所以不用list // 通过localeCompare方法实现按照时间先后顺序比较 // 不能使用减法，在js中如果无法解析为有效数字的字符串，直接返回NaN而导致无法比较，\u0026#39;2023-11-11\u0026#39;形如时间字符串格式，导致无法解析为有效数字的字符串 setComments([...comments].sort((a, b) =\u0026gt; b.time.localeCompare(a.time))) } else { setComments([...comments].sort((a, b) =\u0026gt; b.count - a.count)) } } return ( \u0026lt;div\u0026gt; \u0026lt;div onClick={light}\u0026gt; \u0026lt;span\u0026gt;最新\u0026lt;/span\u0026gt; | \u0026lt;span\u0026gt;最热\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#39;发一条友善的评论\u0026#39;\u0026gt;\u0026lt;/input\u0026gt; \u0026lt;button onClick={addComment}\u0026gt;发布\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; {/* 评论列表 */} \u0026lt;div\u0026gt; \u0026lt;ul\u0026gt; {/* 使用map方法对列表数据进行遍历渲染 */} {comments.map((item, index) =\u0026gt; ( \u0026lt;Item item={item} index={index} /\u0026gt; ))} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Redux介绍 Redux 是React最常用的集中状态管理工具，可以独立于框架运行\nRedux快速体验 实现计数器 需求：不和任何框架绑定，不使用任何构建工具，使用Redux实现计数器 实现步骤 引入Redux库(https://cdnjs.cloudflare.com/ajax/libs/redux/4.1.1/redux.min.js) 定义一个函数，用来作返回修改状态 并 作值的修改处理，如：+的状态 使用Redux的createStore方法传入函数，生成实例对象 使用实例方法subscribe监听数据的变化，通过实例方法getState获取变化后的对象，并且将最新的状态的数据更新到视图中 使用实例方法dispatch提交action对象，触发数据变化 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;计时器\u0026lt;/title\u0026gt; \u0026lt;!-- 引入Redux库 --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/redux/4.1.1/redux.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;del\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;0\u0026lt;/span\u0026gt; \u0026lt;button id=\u0026#34;add\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 定义reducer函数,用来返回修改的状态 function deleteReducer(state = { count: 0 }, action) { switch (action.type) { case \u0026#39;add\u0026#39;: return { count: state.count + 1 } case \u0026#39;del\u0026#39;: return { count: state.count - 1 } default: return state } } // 创建一个Redux store来保存计数器的状态 const store = Redux.createStore(deleteReducer) // 使用store的subscribe方法来订阅状态的变化 store.subscribe(() =\u0026gt; { console.log(\u0026#39;状态更新:\u0026#39;, store.getState()); document.querySelector(\u0026#39;span\u0026#39;).innerText = store.getState().count }) // 使用store的dispatch方法来提交action对象,触发状态的修改 document.getElementById(\u0026#39;add\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { store.dispatch({ type: \u0026#39;add\u0026#39; }) }) document.getElementById(\u0026#39;del\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function () { store.dispatch({ type: \u0026#39;del\u0026#39; }) }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Redux数据流架构 state：一个对象，存放管理的数据 action：一个对象，存放将要调用的功能的类型 reducer：一个函数，根据action提供的类型来调用对应的操作 Redux与React - 环境准备 配套工具 配置基础环境 创建React项目 npx create-react-app react-redux 安装配套工具 npm i @reduxjs/toolkit react-redux\n启动项目 npm run start store目录结构设计 在src目录下创建如下内容\nRedux与React - 实现counter 整体路径熟悉 使用React Toolkit 创建counterStore 配置counterStore模块\nimport { createSlice } from \u0026#39;@reduxjs/toolkit\u0026#39; const counterStore = createSlice({ // 模块名唯一 name: \u0026#39;counter\u0026#39;, // 初始数据 initialState: { count: 0 }, // 修改数据的同步方法 reducers: { increment: state =\u0026gt; { state.count++ }, decrement: state =\u0026gt; { state.count-- } } }) // 解构出actionCreater const { increment, decrement } = counterStore.actions const counterReducer = counterStore.reducer // 导出解构了actionCreater的数据 export { increment, decrement } // 导出reducer函数 export default counterReducer 配置index.js文件\nimport { configureStore } from \u0026#34;@reduxjs/toolkit\u0026#34;; import counterReducer from \u0026#34;./modules/counterStore\u0026#34;; export default configureStore({ reducer: { // 注册子模块 counter: counterReducer }, }) 为react注入store 通过react-redux内置组件Provider，将Redux和React进行连接，通过store参数把创建好的store实例注入进应用，实现Redux store与React的连接建立\n配置index.js\nimport React from \u0026#39;react\u0026#39;; import ReactDOM from \u0026#39;react-dom/client\u0026#39;; import \u0026#39;./index.css\u0026#39;; import App from \u0026#39;./App\u0026#39;; // 导入store import store from \u0026#39;./store\u0026#39;; // 导入store提供的组件Provider import { Provider } from \u0026#39;react-redux\u0026#39;; import reportWebVitals from \u0026#39;./reportWebVitals\u0026#39;; const root = ReactDOM.createRoot(document.getElementById(\u0026#39;root\u0026#39;)); root.render( \u0026lt;React.StrictMode\u0026gt; \u0026lt;Provider store={store}\u0026gt; \u0026lt;App /\u0026gt; \u0026lt;/Provider\u0026gt; \u0026lt;/React.StrictMode\u0026gt; ); React组件使用store中的数据 通过useSelector钩子函数，将store中的数据映射到组件中\nReact组件修改store中的数据 通过hook函数：useDispatch修改store中的数据\nuseDispatch：生成提交action对象的dispatch函数\nimport \u0026#39;./App.css\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import { decrement, increment } from \u0026#39;./store/modules/counterStore\u0026#39; function App() { // 注意这里一定是对象 const { count } = useSelector((state) =\u0026gt; state.counter) const dispatch = useDispatch() return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(decrement())}\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(increment())}\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; Redux与React - 提交action传参 需求：组件中有两个按钮add to 10和add to 20，能够把count值修改到对应的数字，目标count值需要在组件中传递，需要提交action时传递参数\n实现方式\n在reducers对象中添加函数，实现把count值修改到对应数字的功能，并且添加action对象参数 解构并导出该函数 调用dispatch提交action对象，并传递参数，此时参数会传递到action对象中的payload属性上 counterStore配置中的修改\nreducers: { increment: state =\u0026gt; { state.count++ }, decrement: state =\u0026gt; { state.count-- }, // 在reducers中添加函数 addToNum: (state, action) =\u0026gt; { state.count = action.payload } } // 解构并导出addToNum函数 const { increment, decrement, addToNum } = counterStore.actions export { increment, decrement, addToNum } App.js的配置\nimport \u0026#39;./App.css\u0026#39;; import { useDispatch, useSelector } from \u0026#39;react-redux\u0026#39;; import { addToNum } from \u0026#39;./store/modules/counterStore\u0026#39; function App() { // 注意这里一定是对象 const { count } = useSelector((state) =\u0026gt; state.counter) const dispatch = useDispatch() return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{count}\u0026lt;/span\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(addToNum(10))}\u0026gt;add to 10\u0026lt;/button\u0026gt; \u0026lt;button onClick={() =\u0026gt; dispatch(addToNum(20))}\u0026gt;add to 20\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; ","permalink":"http://localhost:1313/posts/react%E7%AC%94%E8%AE%B0%E4%B8%80/","tags":["markdown","React","JavaScript","CSS","HTML"],"title":"React笔记（一）"},{"categories":null,"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0.\rHugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\nhttps://github.com/yuin/goldmark\rhttps://github.com/alecthomas/chroma\rhttps://github.com/muesli/smartcrop\rhttps://github.com/spf13/cobra\rhttps://github.com/spf13/viper\rHugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremely fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub\r.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"About"},{"categories":null,"content":"multilingual中文测试页面\n","permalink":"http://localhost:1313/about.zh-cn/","tags":null,"title":"关于"},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.zh-cn/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/categories/with-slug/with-slug/","tags":null,"title":"自定义 Slug 的分类"},{"categories":null,"content":"","permalink":"http://localhost:1313/tags/custom/custom/","tags":null,"title":"随便一个标签"}]